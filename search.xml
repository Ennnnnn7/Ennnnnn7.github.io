<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[App密码自动填充]]></title>
    <url>%2F2017%2F12%2F25%2FApp%E5%AF%86%E7%A0%81%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%2F</url>
    <content type="text"><![CDATA[iOS和MacOS系统都集成了密码管理系统，网页中输入的密码，系统会询问用户是否存储以便于下一次登录相同网站时自动填充。然而在使用App过程当中，用户很可能已经在网页上登录了账户，却还要再次在手机上输入自己的帐号和密码。有没有更简洁的方式缩短用户登录App的时间来提升用户体验呢？在今年的WWDC 2017上，苹果发布的iOS 11的系统API中便可以实现密码自动填充，并且iOS 11还在系统设置中提供了管理密码的功能。 密码管理当系统获取到用户授权之后会安全的管理密码，并且在需要填写密码时主动提示用户。iOS系统通过iCloud Keychain在登录相同appleID的设备之间共享密码，而iOS 11中，用户必须使用Touch ID 或者密码授权查看存储的密码。接下来就介绍一下如何在App中实现密码自动填充。 密码自动填充要在App中实现密码自动填充有一个必要的前提就是网站需要支持HTTPS协议，这个是必须的。所以要实现密码自动填充需要在App和Website进行设置。 App的设置 设置输入框的textContentType属性分别为username和password。这里的输入框不限于UITextField、UITextView，其他遵循&lt;UITextInput&gt;的视图也可以。textContentType是在iOS 10中添加的一个枚举值，iOS 11中新增了username和password。当账户输入栏和密码输入栏不在同一界面时，设置UITextContentType.username可以在不同界面键盘上均显示提示密码的QuickType Bar。很多App都会使用邮箱作为用户帐号，textContentType中也有emailAddress的选项，而当需要实现密码自动填充时，设置UITextContentType.username与UIKeyboardType.emailAddress就可以解决这个问题。这时，用户就已经可以在登录时，通过点击QuickType Bar右侧的钥匙串按钮，在经过Touch ID验证后，选择需要登录的账户和密码。这里需要注意的是：帐号和密码都会被填充到相应的输入框;当Touch ID界面出现时，App进入不活跃状态，如果登录按钮状态需要随着输入栏输入发生改变，此时应该通过did change代理方法或者通知来进行接下来的操作。 设置Associated Domains在webcredentials:输入关联的域名，例如：webcredentials:www.Ennnnnn7.com这里会发现下面两个勾选中Add the Associated Domains feature to your App ID.选项报错，这里需要登录开发者帐号，在Account-&gt;Certificates,IDs &amp; Profiles-&gt;App IDs 中将绑定的App ID的 Associated Domains勾选，记录Prefix。这样，关于App相关的设置可以告一段落，接下来是对Website的配置。 Website的设置网站中需要在下面的路径中返回对应的JSON。路径： // 将example.com替换为网站的Domain // 两个路径二选一 https://example.com/.wll-known/apple-app-site-association https://example.com/apple-app-site-association JSON： { &quot;webcredentials&quot;:{ // HB22SQJ4Pw 是上面记录下来的Prefix // com.example.Ennnnnn7 是关联应用的 Bundle ID &quot;apps&quot;: [ &quot;HB22SQJ4Pw.com.example.Ennnnnn7&quot; ] } } 这样就实现了在iOS 11系统中的密码自动填充功能，当系统中有已经记录的密码后，用户只需要点击一下QuickType Bar显示的密码，再点击登录按钮就可以有名有份地使用你的App了。 引用WWDC-2017-Introducing Password AutoFill for Apps]]></content>
      <categories>
        <category>WWDC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自动布局——Autoresizing]]></title>
    <url>%2F2017%2F12%2F21%2F%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E2%80%94%E2%80%94Autoresizing%2F</url>
    <content type="text"><![CDATA[时代在进步，科技在发展，层出不穷的硬件在推动着软件技术发展的同时，也会随之而来一些烦恼。经历了十几年的进步，手机屏幕已经从原来硬币大小发展到现在各种材质、多种尺寸的局面。对于开发者来讲，随之而来的便是APP界面适配问题。 导致布局变化的原因导致布局发生变化的原因可以分为外部原因和内部原因两种。 外部原因 不同机型导致屏幕尺寸变化 设备旋转 来电和录音状态栏的显示与消失 内部原因 APP展示内容变化 APP支持国际化 APP支持动态展示 基于硬坐标的方式去布局只是能满足基本功能。由于上述原因导致界面重新布局时需要再次进行计算，界面设计越复杂计算量就越大，而自动布局相较于传统的硬坐标布局具有明显的优势。 布局方式的对比硬坐标布局通过指定视图相较于父视图的原点距离和视图大小来定义视图布局。视图的布局很直观的展示在代码当中，但这种方式需要大量的努力来设计、调试和维护。自动布局通过指定视图之间的约束关系来定义视图布局。这种方式在视图与视图之间建立了一种约束关系，变化是相互响应的，相较于硬坐标布局更加动态。 iOS中有两种自动布局的方法：Autoresizing Masks和Auto Layout。接下来介绍一下Autoresizing Masks。 Autoresizing Masks特性autoresizingMask是UIView的属性，当view.autoresizeSubviews是YES且view.bouns发生改变时，子视图会根据他们的autoresizingMask属性去自适应。 autoresizingMask是一个枚举默认类型，默认为UIViewAutoresizingNone 123456789typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123;UIViewAutoresizingNone = 0,UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0,UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1,UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2,UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3,UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4,UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5&#125;; 枚举值的说明： 属性名 说明 UIViewAutoresizingNone 不会随着父视图的改变而改变 UIViewAutoresizingFlexibleLeftMargin 自动调整view与父视图左边距，保证右边距不变 UIViewAutoresizingFlexibleWidth 自动调整view的宽度，保证左边距和右边距不变 UIViewAutoresizingFlexibleRightMargin 自动调整view与父视图右边距，保证左边距不变 UIViewAutoresizingFlexibleTopMargin 自动调整view与父视图上边距，保证下边距不变 UIViewAutoresizingFlexibleHeight 自动调整view的高度，保证上边距和下边距不变 UIViewAutoresizingFlexibleBottomMargin 自动调整view与父视图下边距，保证上边距不变 autoresizingMask是一个枚举类型，因此可以使用|将多个值分割开组合使用：12// view的宽度按照父视图的宽度比例进行缩放，距离父视图顶部距离不变UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleBottomMargin Autoresizing Masks使用代码实现 需求:保持B视图相较于父视图右边距和下边距不变 代码 12345678910111213141516UIView *parentView = [[UIView alloc] initWithFrame:CGRectMake(20, 100, 200, 60)];parentView.layer.borderColor = [UIColor blackColor].CGColor;parentView.layer.borderWidth = 1.0f;UILabel *bLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 150, 60)];bLabel.text = @&quot;B视图&quot;;bLabel.numberOfLines = 0;bLabel.textAlignment = NSTextAlignmentCenter;bLabel.textColor = [UIColor redColor];bLabel.backgroundColor = [UIColor yellowColor];[bLabel setAutoresizingMask: UIViewAutoresizingFlexibleLeftMargin | UIViewAutoresizingFlexibleTopMargin];[self.view addSubview:parentView];[parentView addSubview:bLabel];[parentView setFrame:CGRectMake(20, 100, 250, 160)]; 实现效果： Storyboard实现由于Storyboard默认使用Auto Layout，需将Auto Layout取消勾选才可以使用Autoresizing 这里要说明一下，在使用Storyboard中的Autoresizing时，实线代表选中，虚线反之。上实线代表子视图距离父视图上边距保持不变，这一点是与代码中UIViewAutoresizingFlexibleTopMargin不同的，需要注意。 总结Autoresizing可以说它是对硬坐标布局的一种拓展以实现自动布局。相较于代码中使用Autoresizing，Storyboard中的使用方式更加直接，方便。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[状态码301与302]]></title>
    <url>%2F2017%2F12%2F07%2F%E7%8A%B6%E6%80%81%E7%A0%81301%E4%B8%8E302%2F</url>
    <content type="text"><![CDATA[最近在看《图解HTTP》这本书，内容很基础，也很简单。一起买来的《HTTP权威指南》相对来说就太“权威”了。接下来会对书中的内容或者个人认为的疑点进行一下总结。 301 、302是什么?301、302等状态码是响应报文中状态行中的组成部分。状态码(Status Code)的职责是当客户端向服务器发送请求时，描述返回的请求结果。标准状态码由3位数字和原因短语组成，主要包含5类： 类别 原因短语 1XX Informational(信息性状态码) 接受的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection(重定向状态码) 需要进行附加操作以完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务器错误状态码) 服务器处理请求出错 301、302代表了什么？ 301 Moved Permanently：永久性重定向。表示请求的资源已被永久分配了新的URI。可以简单理解为该资源已经被永久改变了位置。 302 Found:临时性重定向。表示资源被临时改变位置并分配了新的URI。 两种重定向之后的URI会包含在响应头中Location首部字段中。 301、302区别301永久重定向使得搜索引擎在抓取新内容的同时将旧的网址替换为重定向后的网址。而302临时性定向使得搜索引擎会抓去新的内容却保留旧的网址。 301、302适用场景301：域名切换、HTTP迁移到HTTPS302：未登录用户访问个人中心时重定向到登录页面、404页面提示后跳转到首页 302与网址劫持网址劫持和302重定向有什么关系呢？这个要从搜索引擎如何处理302重定向说起。当从网址A做一个302重定向到网址B时，服务器隐含的意思是网址A可能会重新启用。正常情况，大部分搜索引擎应当去抓取302重定向之后的网址B。但是可能由于B网址相对于A网址过于复杂，这样搜索引擎就会觉得网址A对用户更加友好，因而在重定向之后任然显示旧的网址A，但是显示网址B的内容。这就是网址劫持。在平常使用手机的过程当中，有时候会发现网页上会有浮动的窗口，或者访问的页面不是正常的页面，这就可能是运营商通过某种方式篡改了用户正常访问的页面。其中有一种方式就是通过返回302重定向让用户浏览器跳转到另外的网址。 引用 HTTP 301 HTTP 302 HTTP/1.1 Error codes in RFC 2616 【HTTP劫持和DNS劫持】腾讯的实际业务分析]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[导航栏从透明状态切换为背景图片]]></title>
    <url>%2F2017%2F09%2F05%2F%E5%AF%BC%E8%88%AA%E6%A0%8F%E4%BB%8E%E9%80%8F%E6%98%8E%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2%E4%B8%BA%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[项目有一个需求：导航栏从透明状态切换到指定的背景图片。本来以为只是一个状态的修改，但是现实总是会让我知道自己还是too young too simple。 很简单嘛，一顿操作之后👇🏻 添加导航栏背景图片 123// 设置导航栏透明[self.navigationController.navigationBar setTranslucent:NO];[self.navigationController.navigationBar setBackgroundImage:[UIImage imageByApplyingAlpha:1.f image:LJImageNamed(@&quot;navigationbar&quot;)] forBarMetrics:UIBarMetricsDefault]; 导航栏设置为透明 1234// 设置导航栏不透明[self.navigationController.navigationBar setTranslucent:YES];[self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];[self.navigationController.navigationBar setShadowImage:[UIImage new]]; 事情往往不会像想象中那么顺利的，编译执行后，就有了如下的结果： 这里就发现，在设置self.navigationController.navigationBar.translucent = NO之后，坐标零点从(0, 0)移动到了(0, 64)。那这个translucent属性起什么作用呢？ New behavior on iOS 7.Default is YES.You may force an opaque background by setting the property to NO.If the navigation bar has a custom background image, the default is inferredfrom the alpha values of the image—YES if it has any pixel with alpha &lt; 1.0If you send setTranslucent:YES to a bar with an opaque custom background imageit will apply a system opacity less than 1.0 to the image.If you send setTranslucent:NO to a bar with a translucent custom background imageit will provide an opaque background for the image using the bar’s barTintColor if defined, or blackfor UIBarStyleBlack or white for UIBarStyleDefault if barTintColor is nil.@property(nonatomic,assign,getter=isTranslucent) BOOL translucent NS_AVAILABLE_IOS(3_0) UI_APPEARANCE_SELECTOR; // Default is NO on iOS 6 and earlier. Always YES if barStyle is set to UIBarStyleBlackTranslucent translucent在iOS7 之后有了新的特性。默认为YES。将该属性设置为NO将强制导航栏为不透明的背景。当导航栏背景图是自定义背景图片，该属性的默认值会受到图片的透明度值影响：如果图片中有任何一个像素的透明度小于1，则该属性默认为YES。如果导航栏拥有不透明的自定义背景图时，设置该属性为YES，则系统会将改图片的不透明度置为一个小于1.0的值；如果导航栏拥有透明的自定义背景图时，设置该属性为NO，系统也将会有默认的设定：当barTintColor已经被设置，则将使用该颜色作为图片的背景；反之，则根据barStyle属性设定颜色，UIBarStyleDefault为白色背景、UIBarStyleBlack为黑色背景。 查看文档之后依旧没有解决我遇到的问题，这个时候，那就只能靠GOOGLE了，最终找到了解决的答案：self.extendedLayoutIncludesOpaqueBars = YES;从属性名就可以得知该属性的功能：拓展布局是否包含不透明的导航栏。 至此，需求就算完成了，撒花~~ 资料详解 iOS navigationBar 的设置问题]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[项目中集成QQ登录与分享]]></title>
    <url>%2F2017%2F07%2F03%2F%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90QQ%E7%99%BB%E5%BD%95%E4%B8%8E%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[前言在很多项目中都会使用第三方登录，登录方式大致都是QQ、微信、微博这三个爸爸。下面的文章将会简单介绍一下个人在项目中集成QQ登录与分享功能的流程以及在过程中遇到的问题。 准备工作 首先需要在腾讯开放平台申请成为应用开发者。我注册的是个人开发者，需要提交的材料包括姓名、手机号、身份证号、邮箱、居住地址，最重要的是个人手持身份证的照片（大小限制在2M以内） 下载SDKiOS SDK包中带有两个文件：TencentOpenAPI.framework打包了iOS SDK的头文件定义和具体实现。TencentOpenApi_iOS_Bundle.bundle 打包了iOS SDK需要的资源文件。 SDK环境搭建开发时，我使用的是Xcode 8以及iOS 8+环境。 将TencentOpenAPI.framework和TencentOpenApi_iOS_Bundle.bundle拖入到工程 添加依赖库 关联TencentOpenApi_iOS_Bundle.bundle文件 在工程配置中的“Build Settings”一栏中找到“Linking”配置区，给“Other Linker Flags”配置项添加属性值“-fobjc-arc”。 配置URL Scheme 在iOS9.0以后，需要添加白名单在info.plist文件中加入 LSApplicationQueriesSchemes。SDK中demo下有该字段，可以去复制。 接入代码AppDelegate中代码 引入头文件并遵循代理 处理跳转请求 ViewController.m中代码1.QQ登录1234// appID是在腾讯开放平台创建应用所分配的TencentOAuth *loginOAuth = [[TencentOAuth alloc] initWithAppId:appID andDelegate:self];NSArray *permissions = @[kOPEN_PERMISSION_GET_SIMPLE_USER_INFO, kOPEN_PERMISSION_ADD_SHARE, kOPEN_PERMISSION_GET_INFO, kOPEN_PERMISSION_GET_USER_INFO];[loginOAuth authorize:permissions]; permissions是请求权限类型数组，权限内容如下图：请求登录后，会跳转到手机QQ获取权限，之后可以在回调代理中处理登录状态123456789101112131415/*** 登录成功后的回调*/- (void)tencentDidLogin;/*** 登录失败后的回调* \param cancelled 代表用户是否主动退出登录*/- (void)tencentDidNotLogin:(BOOL)cancelled;/*** 登录时网络有问题的回调*/- (void)tencentDidNotNetWork; QQ登录成功后，如果想要获取QQ用户信息，则可在tencentDidLogin方法中编写下述代码：1234567- (void)tencentDidLogin &#123; // 判断是否获取到Access Token凭证，用于后续访问各开发接口，例如：发表说说到QQ空间、获取用户QQ控件相册列表等 if (_loginOAuth.accessToken) &#123; // 获取用户信息 [_loginOAuth getUserInfo]; &#125;&#125; 接下来，在getUserInfoResponse:方法中获取用户信息:123- (void)getUserInfoResponse:(APIResponse *)response &#123; NSLog(@&quot;用户信息：%@&quot;,response);&#125; 2.QQ分享QQ分享可以分享给好友，也可以分享到QQ空间。 分享URL给好友 123456// 初始化授权登录对象_oauth = [[TencentOAuth alloc] initWithAppId:appid andDelegate:self];QQApiURLObject *urlObject = [QQApiURLObject objectWithURL:[NSURL URLWithString:@&quot;https://itunes.apple.com/cn/app/id1223932262?mt=8&quot;] title:@&quot;团组发票管理&quot; description:@&quot;很好用的哟我开发的哟哈哈哈哈&quot; previewImageData:UIImageJPEGRepresentation([UIImage imageNamed:@&quot;test&quot;], 1) targetContentType:QQApiURLTargetTypeNews];SendMessageToQQReq *req = [SendMessageToQQReq reqWithContent:urlObject];// 分享给好友[QQApiInterface sendReq:req]; 分享到QQ空间 12345_oauth = [[TencentOAuth alloc] initWithAppId:appid andDelegate:self];QQApiTextObject *txtObj = [QQApiTextObject objectWithText:@&quot;这是一段文字哟&quot;];SendMessageToQQReq *req = [SendMessageToQQReq reqWithContent:txtObj];//将内容分享到qqQQApiSendResultCode sent = [QQApiInterface SendReqToQZone:req]; 其他功能SDK中还可以实现其他功能，在这里不一一详述，有需求大家可以仔细阅读文档，或者查看官方Demo中的API。 引用文档 QQ互联-文档资料 Github-QQLoginTest Demo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WWDC 2014 - Session 302 The New iTunes Connect]]></title>
    <url>%2F2017%2F05%2F31%2FWWDC-2014-Session-302-The-New-iTunes-Connect%2F</url>
    <content type="text"><![CDATA[iTunes Connect 应用预览 iTunes Connect 支持15~30s的视频预览展示，最大5张预览图 可以更换预览视频截图（set as Poster Frame） 视频支持H.264或者ProRes两种制式 App Bundles 最多可以将10个App打包在一起 App Bundles将展示第1个App的预览截图 已经购买了包内一个或多个软件，购买包仍需支付App包的费用 App Analytics可以提供App相关数据，例如下载量，用户粘性等。其实就是用户数据统计，国内有百度移动统计、友盟统计等第三方，更贴近入国内实际情况，包括用户在不同省份的统计等等细化的功能。 TestFlight Beta Testing苹果提供的测试分发工具 支持1000名测试人员，而iTunes Connect测试人员仅为25名 不需要将测试人员的设备和UDID加入帐号设备列表，不需要在配置文件中指定测试设备，而是通过邮箱邀请测试人员，测试人员收到邀请后，在TestFlight中可以查看待测试App Sandbox Accounts用于测试App内购功能 App Review Tips 95%的应用在5天以内审核完毕 App名字并不是放关键字的地方，目前很多App的应用名很长，这样可以增加被搜索到的几率，达到宣传作用（但是感觉这条没什么用呀） 应用简介和截图一定要与App功能相符]]></content>
      <categories>
        <category>WWDC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态修改APP图标]]></title>
    <url>%2F2017%2F04%2F01%2F%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9APP%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[在微博上看到了 @安财小小生分享的iOS 10.3新增功能：通过API动态修改APP的图标，自己深入了解了一下。 前言现在每逢公司运营活动需要或者迭代改版，设计就可能对APP图标进行修改。举个例子：去年猴年就有很多APP在图标上添加了紧箍的元素。当活动结束后，图标又会进行更改，每次更改都需要提交版本🤷🏻‍♂️……会不会这个新增功能就是苹果倾听”民意”的结果呢？🤓 实现方法 在Info.plist添加备用图标和默认图标,icon图片名不需要包含文件扩展名CFBundleIcons是一个字典，字典中包含所有APP所有icon信息。字典中的字段包括： CFBundlePrimaryIcon：APP默认icon CFBundleAlternateIcons：APP备用icons UINewsstandIcon：用于Newsstand的icons 实现代码首先需要判断系统是否支持alternate icons,然后通过setAlternateIconName:completionHandler:修改应用图标 审核意见最近在浏览审核指南时看到如下的提示： 4.6 备选 App 图标App 可以使用自定图标以传达特定信息 (例如表达对某个运动团队的喜爱)，前提是每次更改都由用户发起，并且 app 中应包含恢复至原始图标的设置。所有图标变体必须与 app 的内容相关，并且更改内容在所有系统资源之间应保持一致，以便“设置”和“通知”等位置中显示的图标与新的 Springboard 图标相吻合。这项功能不可用于动态、自动或连续性更改，例如用于反映最新天气信息和日历通知等。 参考资料 Information Property List Key Reference 安财小小生Demo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[另类的APP常驻——UIStateRestoration]]></title>
    <url>%2F2017%2F02%2F08%2F%E5%8F%A6%E7%B1%BB%E7%9A%84APP%E5%B8%B8%E9%A9%BB%E2%80%94%E2%80%94UIStateRestoration%2F</url>
    <content type="text"><![CDATA[在之前的项目中被iOS应用后台常驻这一问题所困扰，很多解决方法都有瑕疵，在应用审核时很容易被pass，比如：播放无声音频、调用定位等通过后台任务实现方法。在查看文档时，偶然的机遇发现了UIStateRestoration这个类，这不就能实现类似于”后台常驻”的效果了嘛，果断研究了一下。 UIStateRestoration简介状态恢复(State Restoration)是在应用重新启动时恢复到上一次结束时的状态。当APP切到后台，很难保证应用不被用户或系统杀掉。如果希望应用长时间在前台，显然这种被杀掉的结果不是产品经理想要的。 产品经理：我想要的是当用户打开APP时，给用户一种App从来没有被关闭的感觉，这种无缝顺滑、浑然一体的感觉才是我想要的，要让用户模糊启动和退出的概念。 程序员：哦。 在iOS 6.0中，苹果为我们提供了UIStateRestoration来实现应用状态的保持和恢复。 APP的生命周期这张图很常见吧，大多数APP的生命周期都要遵循以下的状态流程：Not running -&gt; Inactive -&gt; Active -&gt; Background -&gt; Suspended -&gt; Not Running(killed)App从未运行状态，到被用户点击后，进入运行状态，App进入前台，显示启动画面，然后将控制权交给App本身，此时App是活动状态，如果用户点击“Home”键，App会进入后台，如果此时的App没有开启后台多任务支持，在没有特别设计的情况下，不多久App就会进入 Suspended 状态，程序被挂起。如果系统在内存需求足够的情况下，是不会主动杀死这些已经 Suspended 的App的，这样用户在再次启动应用时，App会保持上次退出的状态，这样会给用户带来一种无缝的体验，模糊启动和退出的概念。而当用户主动杀死应用，或者系统因为内存不足而将挂起应用杀死时，用户再次点击APP时会有明显的二次启动的感觉。而当我们开启应用状态保存后，app的状态流程就会是这个样子。 UIStateRestoration接口介绍 苹果推出UIStateRestoration类的目的应该是希望应用能给用户带来顺滑的体验，让APP能快速地还原到用户上次的停留点。接下来让我们开始吧！ 1.在Application Delegate中启动状态保持12345678// 开启应用状态保存- (BOOL) application:(UIApplication *)application shouldSaveApplicationState:(NSCoder *)coder &#123; return YES;&#125;// 开启应用状态回复- (BOOL)application:(UIApplication *)application shouldRestoreApplicationState:(NSCoder *)coder &#123; return YES;&#125; 当shouldSaveApplicationState回调是在进入后台的瞬间询问的，如果返回值是YES，程序会在当前应用的沙盒文件中Library文件夹下创建状态保存目录Saved Application State用于存储相关数据。 在存储数据的同时，程序还会创建一个快照，以替换Default.png在iOS App switcher中显示，我们在下次启动的时候， 就不会显示默认的启动图片， 而是上次退出应用前的UI快照。 2.UIViewController操作当需要对具体UI进行操作时，需要在UIViewController中通过接口来实现状态的保存。 下面简单介绍一下这些接口功能： restorationIdentifier：为当前的ViewController 设置一个标识，以在恢复时使用。 restorationClass：类名，在恢复时使用，此类需要实现 UIViewControllerRestoration。 encodeRestorableStateWithCoder：序列化时回调接口，用于手动存储当前的对象的状态。 decodeRestorableStateWithCoder：实例化时回调接口，用于手动恢复存储对象的状态。 applicationFinishedRestoringState：在实例化完成后调用，可以用于完成一些附加的业务逻辑。 举个例子： 调试方法 在Xcode中运行程序 在模拟器/真机设备上按Home键返回桌面 在Xcode中结束程序运行 再次run，run，run 后记 多看文档有好处 文章大部分是引用别人已有成果，我只不过是站在巨人的肩膀上以自己的逻辑来写文章 如果有不对之处，还希望指出来。 关于不同设备Crash的临界值可以通过下面的链接查看别人的答案，其中还分享了一个测试Crash临界值的工具。苹果设备内存Crash临界值查询 引用 iOS UI 的快速还魂之道 State Preservation and Restoration DEMO地址 State Preservation and Restoration的Demo 苹果官方示例]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UITableView分割线顶头]]></title>
    <url>%2F2017%2F01%2F20%2FUITableView%E5%88%86%E5%89%B2%E7%BA%BF%E9%A1%B6%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[当UITableView的style设置为UITableViewStylePlain时，最后一个Cell的分割线没有顶头。作为一个处女座，强迫症又犯了，Stack overflowe上找到了解决方法，拿出小本本记一下。 方法一：将TableView的类型设置为UITableViewStyleGrouped这样每个分区的第一行和最后一行分割线是顶头的。 方法二：在代理方法中修改分割线的约束代码如下 12345678910111213141516-(void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (indexPath.row == ([tableView numberOfRowsInSection:indexPath.section] - 1)) &#123; // Remove seperator inset if ([cell respondsToSelector:@selector(setSeparatorInset:)]) &#123; [cell setSeparatorInset:UIEdgeInsetsZero]; &#125; // Prevent the cell from inheriting the Table Views margin settings if ([cell respondsToSelector:@selector(setPreservesSuperviewLayoutMargins:)]) &#123; [cell setPreservesSuperviewLayoutMargins:NO]; &#125; // Explictly set your cell&apos;s layout margins if ([cell respondsToSelector:@selector(setLayoutMargins:)]) &#123; [cell setLayoutMargins:UIEdgeInsetsZero]; &#125; &#125;&#125; 这里我只添加了最后一个cell的分割线。 方法三：设置cell的separatorInset属性通过设置cell.separatorInset = UIEdgeInsetsMake(0, 0, 0, 0);可以将分割线顶头。但是当设置left为正数时，整个contentView内控件都会发生偏移，个人认为可以只用作设置分割线顶头来用。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用WKWebView访问Https]]></title>
    <url>%2F2017%2F01%2F17%2F%E4%BD%BF%E7%94%A8WKWebView%E8%AE%BF%E9%97%AEHttps%2F</url>
    <content type="text"><![CDATA[开发的项目需要政府网站，网站实用的是Https，而且网页上提示首次使用请下载证书，想了好多方法，最后发现可以通过WKWebView来实现访问。 遇到的问题 首次使用需要下载证书 网站证书为自建证书 网站验证码图片显示必须下载证书 解决方法 首先在项目中设置Infoplist-&gt;ATP 从网站下载证书，将证书格式设置为der或cer格式，在终端中修改方法：.crt转.der的方法 openssl x509 -in /Users/mac/Desktop/ca.crt -out /Users/mac/Desktop/ca.der -outform DER.crt转.cer方法： openssl x509 -in /Users/mac/Desktop/ca.crt -out /Users/mac/Desktop/ca.cer -outform DER 导入证书直接把证书拉到项目中 WKWebView设置代理WKNavigationDelegate,在代理方法webView:didReceiveAuthenticationChallenge:completionHandler中设置证书信任 这样，就可以正常的访问这个网站了！！撒花~~ 后记之前采用UIWebView可以绕过证书验证这一步，可是验证码图片必须有证书才可以显示。被这个折磨了一天，第二天用了WKWebView一下子就解决问题了，而且，WKWebView的性能还要优于UIWebView。还是需要不断努力呀！！！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods吐血安装过程]]></title>
    <url>%2F2016%2F11%2F15%2FCocoaPods%E5%90%90%E8%A1%80%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在之前工作中，第三方框架都是直接拖到工程中，这样太繁琐了，工作量大不说，在第三方代码版本管理也是一个很头疼的问题。后来采用了CocoaPods，一切就变得那么简单了，新项目虽然不大，但是自己还是使用了CocoaPods，这里把自己吐血安装的过程总结一下，真的是吐血呀。文章默认电脑是第一次安装CocoaPods，内容是按照安装的过程以及遇到的问题和解决方法这种方式来描述的，我觉得这样比最后总结问题更直接一些。PS.友情提示一下，安装CocoaPods一定要保持良好的网速。因为自己在安装过程中公司网速影响了好多，回家之后网速快了，问题也就没了。。。 一、什么是CocoaPodsCocoaPods是一款第三方代码库的依赖管理工具，它可以在开发OS X或者iOS应用程序过程中对第三方框架进行搞笑的控制管理。这样开发者在配置成功CocoaPods之后，可以通过简单的命令就可以管理第三方库。而且，目前大部分开源类库都已支持CocoaPods。 二、安装CocoaPods我是通过终端来安装的，打开Mac终端输入命令行来安装CocoaPods。 输入命令sudo gem install cocoapods【解释】：这行命令是安装CocoaPods的命令。【可能出现的问题】：由于CocoaPods是采用Ruby实现的，所以Mac必须有Ruby环境。Ruby的默认源使用的是cocoapods.org,此网址在国内访问会出现问题。 修改Ruby源 移除之前的Ruby路径gem sources --remove https://rubygems.org/ 更换新的路径这里要说明一下：之前是添加淘宝镜像gem sources -a https://ruby.taobao.org。但是目前淘宝的镜像已经停止更新了，停止更新公告 良心的淘宝当然给了我们解决方法： 添加Ruby China的镜像gem sources --add https://gems.ruby-china.org/ 由于我是第一次安装，之前已经移除了系统中当前的镜像，所以不用像链接内的方法移除当前镜像； 检查当前镜像gem sources -l,确保只有gems.ruby-chaina.org 输入命令gem install rails（这里需要一段时间） 再次输入sudo gem install cocoapods 输入pod setup如果没什么问题你就安装CocoaPods成功了，如何检查是否安装成功呢： 终端输入pod --version,显示出版本即为成功； 终端输入pod repo list,若结果为0 repos时说明没有安装成功。 三、可能出现的问题 Q：ERROR：while executing gem ...(ERROR::EPERM) Operation not permitted - /usr/bin/podA：Stackoverflow上的解释是：This is happening because Apple has enabled rootless on the new install，也就是说在OS X EI Capitan（10.11）系统上苹果已经启动了无根的安装。在终端重新输入sudo gem install -n /usr/local/bin cocoapods Q:Error installing pods:active support requires Ruby version &gt;= 2.2.2A:需要Ruby版本不小于2.2.2。解决方法我参照了Ruby环境更新这篇文章。 Q：终端出现Setting up CocoaPods master repo之后没有任何变化A：说明CocoaPods正在将它的信息下载到 ~/.cocoapods中（这一步是很费时间的，等输出Setup completed 安装完成啦）PS.可以重新打开另一个终端，输入 cd ~/.cocoapods进入cocoapods文件夹——&gt;输入`du -sh *查看进度。这一步一点要保证网速，这一步一定要保证网速，这一步一定要保证网速。 Q:pod setup时出现以下错误： [!] /usr/bin/git clone https://github.com/CocoaPods/Specs.git master Cloning into &apos;master&apos;... error: RPC failed; curl 56 SSLRead() return error -36 fatal: The remote end hung up unexpectedly fatal: early EOF fatal: index-pack failed You can try adding it manually in \`~/.cocoapods/repos\` or via \`pod repo add\`. A:重新安装（其实我就是这样安装成功的）：首先，删除.cocoapods目录，在终端输入：sudo rm -rf ~/.cocoapods/然后，重新下载安装，在终端输入命令：pod setup Q：出现下面报错时： ERROR: While executing gem ... (TypeError) no implicit conversion of nil into String A：更新gem sudo gem update --system 四、使用CocoaPods 终端中cd到项目所在路径，创建Podfilevim Podfile 按下i键进入输入状态，在Podfile文件里输入以下文字： 123platform :ios, &apos;8.0&apos;target &apos;Your_App_Name&apos; dopod &apos;AFNetworking&apos;, &apos;~&gt;3.0&apos; 按下esc键退出输入。然后保存退出，命令是:wq。你当然可以使用vim之外的编辑软件来编辑Podfile文件。 注：cocoapods-1.0.0.beta版本后规定Podfile文件必须如上所示（加target） 终端cd到你的项目所在目录下执行如下命令来利用CocoPods下载第三方库：pod install 五、参考文章 iOS的库依赖管理工具CocoaPods iOS–cocoapods安装(为走过的坑留个纪念)]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[怪诞行为学]]></title>
    <url>%2F2016%2F08%2F18%2F%E6%80%AA%E8%AF%9E%E8%A1%8C%E4%B8%BA%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[前言当当当当，自己的拖延症还是没有治好，这本书断断续续看了将近3个月，3个月来一直在书包里放着，坐地铁有时间看一看，坐火车有时间看一看（好多书都是在坐火车是看完的，毕竟没人打扰且时间完整），到今天，我终于把它看完了。首先要讲讲这本书的由来：《怪诞行为学》这本书是在2015年新年时公司发的礼物（之前征集过新年愿望），一共好几本书，它便是其中之一。之前同学读过这本书，而且网上评价很不错，所以自己当然也要学习学习啦。 作者介绍 丹·艾瑞里（Dan Ariely），行为经济学和电子商务领域中十分活跃的国际知名学者 作者在高中时期因为一次意外导致全身70%面积的三度烧伤，在几年治疗期间，他以一种局外人的身份来观察人的行为并对心理学产生兴趣。他通过对自己亲身经历的研究说服当年那些给自己换药的护士：“长痛不如短痛”的观念是错误的，温柔的换纱布对患者造成的痛苦更小。 书籍介绍《怪诞行为学》是一本心理学书籍，书中作者以实验数据来准确说明自己的理论：人类的判断与决策往往不全是理性的，在理性当中还有非理性的存在。作者从心理学的角度来验证传统经济学的缺陷：人们有时不会沿着既定的行为轨迹前行，而这些变数正是传统经济学需要考虑并加以解决的。 第一章：相对论的真相本章主要描述了不同事物之间对比对我们的判断产生的影响。 在相同价格的基础上，选择类别多一些的产品往往会被我们放到购物车，例如：买一赠一或者满100有赠品。以我自己举例,在淘宝购物时看到心仪的商品后，和卖家不拉不拉半天，在我心里已经下决定要买的时候我经常会问一句：有赠品吗。这个时候如果商家支支吾吾给我赠品后，我的喜悦感就会蹭蹭的直线上涨，感觉自己卖脸又成功了；相反，没有赠品我也会买这件我心里已经下单的商品，然而剁手的喜悦感可能就很淡淡了。多就是赚了的想法正是商家抓住消费者的心理，但是大多数情况下赠品的出现冲淡了我们对自己想买的商品的关注度。但是，这些赠品是我们真正需要的吗？而且有的赠品真的是惨不忍睹呀。 追求更高的生活享受是每个人正在努力争取的，但是在这一过程中，当我们看到更富有的人的生活时，我们内心的羡慕妒忌会让我们做出错误的行为:你可能去买自己需要分期付款的高档手表、享受自己目前经济水平不等的生活标准。这个时候我们要打破相对论的怪圈，选择最合适自己当前的，而不是盲目的攀比。 作者在第17页中举例： 有人会很轻易的在价值5000美元的宴会上多加一道200美元的带汤主菜，也会去从价值1美元的浓缩汤罐头里通过优惠券节省25美分。类似的，我们给一辆25000美元的汽车加装3000美元的真皮座椅不觉得贵，却不愿意花同样的钱买一套真皮沙发。 这边是相对论在作祟，再有对比过程中，我们不太容易拓宽视野，我们的思维被局限，我们不能“控制”我们自然的思考方式。 第二章：供需关系的失衡 对于事物的第一印象会影响我们对同类产品的比较，这就是锚定。锚定具有持续性，当一个锚定已然形成，我们对之后事物的判断也会基于这一锚定。想想我们第一次在学校门口吃煎饼果子是3块钱，当你的同学请你去他们学校，同样你也吃了煎饼果子，可是这个煎饼果子要5块钱，你肯定会和你同学说：你们学校的煎饼太贵了！！！ 羊群效应：基于他人的行为来判断某事物的好坏已决定我们是否效仿。现实中的例子很多：吃饭我们会去人多的馆子、看电影有人会先看影评在决定今天看什么电影……书中作者以星巴克举例来验证自我羊群效应：当我们第一次喝星巴克觉得不错，下次路过星巴克我们肯定会回想起之前美妙的体验，我们会再次去星巴克消费，喝我们上次喝过的咖啡。 第三章：免费的代价0会成为一个非理性兴奋的来源，免费最大的问题在于它引诱你在它和另外一件商品之间挣扎——并引导我们做出不理智的决定。免费往往花费更多，当作者想要购买一部DVD时，商家7张免费高清碟片对作者产生了巨大的诱惑。免费就像地心引力一样，实在让我们难以抗拒。另外一个例子：两款不同的巧克力，好时定价10元，好运定价3元。我们在购买时会考虑好时带给我们的快感-价格的差值会大于好运巧克力。但当他们同时降价3元，按照公式差值没变。但是，你会购买7元的好时还是免费的好运呢？每次看到超市大减价，主妇、大妈便会磨拳擦掌的杀向她们的战场；双十一、双十二、发烧节等等电商推出的“节日”就是通过大优惠来造势，吸引大众去消费，而消费的冲动还会让我们购买预期之外的商品，“这么便宜错了可就错过了”所以，想让顾客盈门，拿出点免费的东西！想增加销售？放点血拿出点免费赠品吧。 第四章：社会规范的成本 要区分社会规范与市场规范，一旦两者有参杂，两种规范都会失效我觉得社会规范是一种互帮互助的道德行为，我为人人，人人为我，双方在心里都认同对方。社会规范的具体行为十分普遍，用我的亲身经历来举一个例子吧。 昨天我出门约人小聚吃饭，平常出门我有一个习惯：不论路程远近都会携带背包以备不时之需。这次就只是吃个便饭，所以我就带了手机、信用卡、50块钱出门了。等了老长时间公交车终于来了，我向往常一样排队、上车、刷卡，这时候我没有听到熟悉的“滴”，我把公交卡和刷卡器蹭了半天也没有一个声响——我告诉自己：公交卡没磁了。我把我的50块钱递给售票员大姐，大姐说了句：这儿车市无人售票，你有零钱没？尴尬……尴尬……我就带了3样东西出门，并没有零钱。和大姐说了情况，大姐一句话瞬间让我觉得暖暖的：诶！后面找个座坐下吧，谁没有个困难的时候。这就是我觉得体现社会规范的一个例子：你不会去朋友家吃饭后付款、你不会像你的约会伴侣提自己为了约会花了多少钱。在工作中，雇佣关系数据市场关系，如果为了提升员工对公司的忠诚，社会规范是最好的办法。 像谷歌一类的公司，他给雇员提供多种多样的福利（包括精美的午餐），就可以看出强调雇佣关系中社会性的一面所能营造出的亲善氛围。当社会规范强于市场规范时，员工恩呢各位公司创造的价值的确令人瞩目。 想想年会上的抽奖礼物，有时候我们可能更希望直接发现金给我们，但是，这样就相当于将市场规范引入，而市场规范与社会规范不可兼得，而且当二者同时存在时，社会规范必将退出。换言之，社会规范很难重建。金钱到最后经常是最昂贵的激励方式 第五章：性兴奋的影响 我们很难在冷静状态下判断兴奋状态下的行为。书中作者通过“性兴奋实验”来验证这一理论，试验中实验参与者冷静状态下的判断与性兴奋状态下对相同问题的偏好均有一定程度的偏差。举一条实验数据：对于【女人的鞋子会激发性欲吗？】这一问题，非兴奋状态下的数值是42，兴奋状态下是65（“否”代表0，“可能”代表50，“是”代表100）。 通过实验数据完全揭示出，在非兴奋状态中，他们不知道自己在兴奋状态下会怎样。预防、保护、节制以及道德感在雷达屏幕上全部消失了。他们没有能力预测激情会把他们改变到何种程度。 我们在冷静状态下是一个人，兴奋状态下是另外一个人，我们无法做到自控。如何预防这些问题的发生呢？我们需要在我们处于难以自控之前就对自己说“不”，预防事件的发生，毕竟抵抗诱惑困难，深陷诱惑之中与之斗争更困难。 第六章：拖沓的恶习和自我控制 【抵制诱惑】：灌输自制意志是人类总体的目标。一再失败、少有成功则是我们很多痛苦的来源之一。书中作者通过【完成论文时间】实验来验证拖沓恶习。实验中，作者要求自己的学生在12周中完成3篇论文，试验中一共有三个班级: 第一个班级的学生可以自己规划论文上交时间； 第二个班级只要在学期末最后一节课直接上交3片论文即可； 第三个班级严格要求3篇论文的上交时间； 结果最终完全限定论文上交时间的班级成绩最好，完全没有限制的班级成绩最差，而自己规划上交时间的班级成绩在这两者之间这和我们写暑假作业一样，很多人会在开学前一天熬夜补暑假作业，相信很多人会有这样的经历。2. 如何改变拖沓的习惯和想法呢？设立简单易懂的执行方案解决拖沓。我们可以将需要处理的事件，拆分成几部分，这样在我们完成一部分后，就相当于到达一个里程碑，这将激励我们去完成接下来需要处理的一部分，激发我们工作的动力。 自制力除了体现在懒惰之外，还体现在对喜爱事物的过度消费。大二时，自己会不间断的暴饮暴食；平时自己也会深陷手机不能自拔；信用卡会让我们去过度消费。 第七章：所有权的个性 所有权的怪癖a.对已拥有的东西迷恋到无法自拔b.把注意力集中到自己会失去什么，而不是会得到什么（对失去的恐惧）c.假定别人看待交易的角度与自己相同 宜家效应：投入越多，感情越深虚拟所有权：在实际拥有某一物品之前对其产生的感觉3.去拥有心态 第八章：多种选择的困境果断的做出最正确的决定，不要犹豫不决 第九章：预期的效应1.预期改变人们对体验的认识与品评2.预期可以形成成见，成见为我们不断的理解周围复杂的环境提供了便捷3.成见的激活则却绝于我们当时的心理状态和自我认知4.通过造句练习，启动实验者心中的成见（这是社会心理学中常用的技术手段）5.偏见化思维是绝大多数冲突升级的主要根源 第十章：价格的魅力当人们信任一件事情，会产生相应的影响，这就是一种暗示的效应。 第十一章：人性的弱点诚信在道德准则上的约束更起作用 第十二章：企业的特权我们擅长把自己细微的不诚实想法和做法合理化。即使外部事物不可理解，我们只要尝试从自身所处的环境进行解读，也可以从中收益。 引用【果壳网专访】丹•艾瑞里：我是你的怪诞行为导游]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown简单使用方法]]></title>
    <url>%2F2016%2F08%2F14%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[之前一直没有总结的习惯，也吃过不少亏，总觉得自己词穷外加写文章和流水账一样。但是，不改变肯定是在给自己挖坑，借着离职之后的时间，对自己在之前工作中的一些知识点进行总结，加深一下印象。 一、Markdown简介Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。通过一些规定的语法，可以对文本格式进行简单的修改，还可以添加图片、链接。Markdown的语法相较于复杂的HTML语言十分轻量（这也是我学习Markdown语言的原因），对于程序员来说，文字、代码引用、图片这些是总结中大量使用的材料，不需要过多的排版，简单的Markdown就可以满足日常的码字总结。Markdown同时兼容HTML语言，如果为了更加美观可以使用HTML语言语法来修饰文章。 什么人适合学习Markdown任何工具的出现都是为了能够加快工作效率的，但是并不是所有人都适合学习Markdown。Markdown是为那些需要经常码字或者进行文字排版的、对码字手速和排版顺畅度有要求的人群设计的，他们希望用键盘把文字内容啪啪啪地打出来后就已经排版好了，最好从头到尾都不要使用鼠标。这些人包括经常需要写文档的码农、博客写手、网站小编、出版业人士等等。 二、Markdown的优点 专注于文字内容，简单的排版即可满足 语法简单，可读性强，学习成本低 兼容性强相对于Word、Pages，Markdown显得十分简单，像一个不沾粉黛的青衣少女，和外面那些妖艳贱货不一样。 三、Markdown的语法 Markdown中文版语法说明 详细内容可以从上面的链接查询，接下来我会简单介绍一些常用的语法 标题标题是一篇文章开头和某些段落开头必须的内容，在Markdown语法中，一段文字如果是标题，在文字之前使用#即可（标题阶数一共6阶）。# 一级标题 一级标题###### 六级标题 六级标题分割线你可以在一行中用3个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：*** ---分割线样式如下 列表无序列表使用* -有序列表使用1. 2.注：符号和.后要有空格 一 二 三 引用在需要引用的文字段落前使用&gt;即可引用段落。而且在引用段落中还可以使用其他Markdown语法。 这是引用的内容 二级引用 代码块在Markdown中，使用2个```包裹代码块即可，代码块的缩进使用Tab缩进。 1234UILabel *nameLabel = [[UILabel alloc] init];if ([nameLabel isKindofClass]) &#123; NSLog(@&quot;%@&quot;,@&quot;Name&quot;)&#125; 图片和链接链接使用[](),[]中是链接的介绍，()中输入链接图片使用![]()，与链接中括号输入的内容一致（图片需要使用图床地址） 文字强调使用*文本*来实现文字斜体使用**文本**来实现文字加粗使用***文字***来实现文字斜体加粗 反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 页面内部跳转 设置锚点：&lt;span id = &quot;anchor&quot;&gt;锚点&lt;/span&gt; 跳转[锚点](#anchor)注：[]内是要填转的按钮显示的文字,小括号内#后面是跟的id值.因为跳转是根据id跳的。 以上，就和Markdown一样简洁（因为没图）。]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
</search>
